<!doctype html>
<html lang="ja">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, height=device-height, minimum-scale=1, maximum-scale=1, initial-scale=1, user-scalable=no">
        <meta name="referrer" content="no-referrer">

        <script>
            if(!window.SubtleCrypto){
                alert("ご使用のウェブブラウザは非対応です");
                document.execCommand("stop");
            }
        </script>

        <title>公開鍵暗号化ツール</title>
    </head>

    <body>
        <header>
            <h1>公開鍵暗号化ツール</h1>
        </header>

        <main>
            <section>
                <h2>暗号化/復号</h2>

                <ul class="input">
                    <li>
                        <div>データ</div>
                        <input type="file" accept=".zip,.bin" id="data">
                    </li>

                    <li>
                        <div>公開鍵</div>
                        <input type="file" accept=".pub" id="public">
                    </li>

                    <li>
                        <div>秘密鍵</div>
                        <input type="file" accept=".sec" id="secret">
                    </li>
                </ul>

                <p>
                    <button type="button" id="convert">&#x1F510; 暗号化/復号</button>
                    <button type="button" id="generate">&#x1F511; 鍵生成</button>
                </p>
            </section>

            <section>
                <h2>ドキュメント</h2>

                <details>
                    <summary>使用方法</summary>

                    <h3>はじめに</h3>
                    <ul>
                        <li>暗号化が可能なデータは、ZIPアーカイブ(拡張子: <code>zip</code>) のみとなります。</li>
                        <li>送信したいデータは、あらかじめ ZIP圧縮(非暗号化) を行う必要があります。</li>
                    </ul>

                    <h3>STEP1: 鍵を生成する (操作: 送信者/受信者)</h3>
                    <ol>
                        <li>送信者と受信者は、それぞれ <a href="#generate">鍵生成</a> ボタンを押し、処理を開始します。</li>
                        <li>秘密鍵を保護するためのパスワード設定を求められるので、推測されにくい値を入力します。</li>
                        <li>処理が完了すると、2個のファイルがダウンロードされます。(許可を要求された場合は許可します)</li>
                        <ul>
                            <li><code>key-{乱数}.pub</code> : 公開鍵(公開しても問題ない)</li>
                            <li><code>key-{乱数}.sec</code> : 秘密鍵(絶対に公開してはいけない)</li>
                        </ul>
                    </ol>

                    <h3>STEP2: 公開鍵を交換する (操作: 送信者/受信者)</h3>
                    <ol>
                        <li>送信者と受信者は、それぞれ生成した <code>public.key</code> を、電子メールなどで相互に交換します。</li>
                    </ol>

                    <h3>STEP3: 暗号化を行う (操作: 送信者)</h3>
                    <ol>
                        <li>送信者は、ツールの各フォームへファイルを入力します。</li>
                        <ul>
                            <li><a href="#data">データ</a> フォーム : 暗号化したい ZIPアーカイブ</li>
                            <li><a href="#public">公開鍵</a> フォーム : 受信者から受け取った <code>public.key</code></li>
                            <li><a href="#secret">秘密鍵</a> フォーム : 自身で生成した <code>secret.key</code></li>
                        </ul>
                        <li><a href="#convert">暗号化/復号</a> ボタンを押し、処理を開始します。</li>
                        <li>秘密鍵のパスワードを求められるので、鍵生成のときに設定したパスワードを入力します。</li>
                        <li>処理が完了すると、1個のファイルがダウンロードされます。</li>
                        <ul>
                            <li><code>cipher.bin</code> : 暗号データ(公開しても問題ない)</li>
                        </ul>
                    </ol>

                    <h3>STEP4: 暗号データを送信する (操作: 送信者)</h3>
                    <ol>
                        <li>送信者は、暗号化された <code>cipher.bin</code> を、電子メールなどで受信者へ渡します。</li>
                    </ol>

                    <h3>STEP5: 暗号データを復号する (操作: 受信者)</h3>
                    <ol>
                        <li>受信者は、ツールの各フォームへファイルを入力します。</li>
                        <ul>
                            <li><a href="#data">データ</a> フォーム : 送信者から受け取った <code>cipher.bin</code></li>
                            <li><a href="#public">公開鍵</a> フォーム : 送信者から受け取った <code>public.key</code></li>
                            <li><a href="#secret">秘密鍵</a> フォーム : 自身で生成した <code>secret.key</code></li>
                        </ul>
                        <li><a href="#convert">暗号化/復号</a> ボタンを押し、処理を開始します。</li>
                        <li>秘密鍵のパスワードを求められるので、鍵生成のときに設定したパスワードを入力します。</li>
                        <li>処理が完了すると、1個のファイルがダウンロードされます。</li>
                        <ul>
                            <li><code>raw.zip</code> : 元データ(通常のZIPアーカイブ)</li>
                        </ul>
                    </ol>
                </details>

                <details>
                    <summary>技術仕様</summary>

                    <ul>
                        <li>実装: <a href="https://www.w3.org/TR/WebCryptoAPI" target="_blank" rel="noopener">Web Crypto API</a></li>
                        <li>鍵交換: <a href="https://ja.wikipedia.org/wiki/楕円曲線ディフィー・ヘルマン鍵共有" target="_blank" rel="noopener">ECDH</a></li>
                        <li>公開鍵: <a href="https://datatracker.ietf.org/doc/html/rfc4492" target="_blank" rel="noopener">NIST P-521</a> - 521bit Key</li>
                        <li>共通鍵: <a href="https://ja.wikipedia.org/wiki/Advanced_Encryption_Standard" target="_blank" rel="noopener">AES-GCM</a> - 256bit Key, 128bit Tag, 128bit IV (96bit Nonce + 32bit Counter)</li>
                    </ul>
                </details>

                <details>
                    <summary>安全性</summary>
                    <ul>
                        <li>暗号処理は全てローカルで完結するため、インターネット通信を伴う処理はありません。</li>
                        <li>サードパーティ製のライブラリは使用していません。</li>
                        <li>MITライセンス準拠のオープンソースソフトウェアとなります。</li>
                        <li>ハッシュ値: <a href="https://dojyorin.github.io/web-crypto/sha512.txt" target="_blank" rel="noopener">SHA512</a></li>
                        <li>リポジトリ: <a href="https://github.com/dojyorin/web-crypto" target="_blank" rel="noopener">GitHub</a></li>
                        <li>お問い合わせ: <a href="https://twitter.com/dojyorin" target="_blank" rel="noopener">Twitter</a></li>
                    </ul>
                </details>
            </section>
        </main>
    </body>

    <script async type="module">
        function $id(id){
            return document.getElementById(id);
        }

        function concatBuffer(...arrays){
            return arrays.reduce((c, array)=>{
                c.byte.set(new Uint8Array(array?.buffer ?? array), c.offset);
                c.offset += array.byteLength;
                return c;
            }, {
                byte: new Uint8Array(arrays.reduce((c, {byteLength}) => c += byteLength, 0)),
                offset: 0
            }).byte.buffer;
        }

        function CONFIG_PBKDF2(v){
            return {
                name: "PBKDF2",
                hash: "SHA-512",
                iterations: 0xFFFF,
                salt: v
            };
        }

        function CONFIG_CURVE(){
            return {
                name: "ECDH",
                namedCurve: "P-521"
            };
        }

        function CONFIG_ECDH(v){
            return {
                name: "ECDH",
                public: v
            };
        }

        function CONFIG_AES(){
            return {
                name: "AES-GCM",
                length: 256
            };
        }

        function CONFIG_GCM(v){
            return {
                name: "AES-GCM",
                tagLength: 128,
                iv: v
            };
        }

        async function derivePassword(pw, salt){
            return crypto.subtle.deriveKey(CONFIG_PBKDF2(salt), await crypto.subtle.importKey("raw", new TextEncoder().encode(pw), "PBKDF2", false, ["deriveKey"]), CONFIG_AES(), false, ["wrapKey", "unwrapKey"]);
        }

        async function exportKey(pw){
            const iv = crypto.getRandomValues(new Uint8Array(12));
            const salt = crypto.getRandomValues(new Uint8Array(16));

            const {publicKey, privateKey} = await crypto.subtle.generateKey(CONFIG_CURVE(), true, ["deriveKey"]);

            return {
                pub: await crypto.subtle.exportKey("spki", publicKey),
                sec: concatBuffer(iv, salt, await crypto.subtle.wrapKey("pkcs8", privateKey, await derivePassword(pw, salt), CONFIG_GCM(iv)))
            };
        }

        async function importKey(pub, sec, pw){
            return {
                pub: await crypto.subtle.importKey("spki", pub, CONFIG_CURVE(), false, []),
                sec: await crypto.subtle.unwrapKey("pkcs8", sec.slice(28), await derivePassword(pw, sec.slice(12, 28)), CONFIG_GCM(sec.slice(0, 12)), CONFIG_CURVE(), false, ["deriveKey"])
            };
        }

        async function deriveKey(pub, sec){
            return crypto.subtle.deriveKey(CONFIG_ECDH(pub), sec, CONFIG_AES(), false, ["encrypt", "decrypt"]);
        }

        async function encryptData(com, data){
            const iv = crypto.getRandomValues(new Uint8Array(12));

            return concatBuffer(iv, await crypto.subtle.encrypt(CONFIG_GCM(iv), com, data));
        }

        async function decryptData(com, data){
            return crypto.subtle.decrypt(CONFIG_GCM(data.slice(0, 12)), com, data.slice(12));
        }

        function writeFile(data, name){
            const link = document.createElement("a");
            link.href = URL.createObjectURL(new Blob([data]));
            link.download = name;

            link.click();

            URL.revokeObjectURL(link.href);
        }

        function openNotify(message){
            const dialog = document.createElement("dialog");
            dialog.style.position = "fixed";
            dialog.style.top = "10px";
            dialog.style.transition = "all 0.1s";
            dialog.style.border = "0";
            dialog.style.borderRadius = "8px";
            dialog.style.padding = "10px 15px";
            dialog.style.backgroundColor = "#CACACA";
            dialog.style.boxShadow = "2px 3px 4px 0 #0000004D";
            dialog.textContent = `\u{1F514} ${message}`;

            dialog.show();

            setTimeout(() => dialog.remove(), 5000);
            document.body.appendChild(dialog);
        }

        $id("convert").addEventListener("click", async()=>{
            if(["data", "public", "secret"].some(e => $id(e).files.length !== 1)){
                openNotify("ファイルを選択してください");
                return;
            }

            const pw = prompt("秘密鍵に設定されているパスワードを入力してください");

            if(!pw){
                openNotify("処理をキャンセルしました");
                return;
            }

            try{
                const {pub, sec} = await importKey(await $id("public").files[0].arrayBuffer(), await $id("secret").files[0].arrayBuffer(), pw);
                const com = await deriveKey(pub, sec);
                const data = await $id("data").files[0].arrayBuffer();

                switch($id("data").files[0].name.split(/\./).pop().toLowerCase()){
                    case "zip":
                        writeFile(await encryptData(com, data), "cipher.bin");
                    break;

                    case "bin":
                        writeFile(await decryptData(com, data), "raw.zip");
                    break;

                    default:
                        throw "Unsupported extension.";
                    break;
                }

                openNotify("処理が完了しました");
            }
            catch{
                openNotify("処理中にエラーが発生しました");
            }
        });

        $id("generate").addEventListener("click", async()=>{
            const pw = prompt("秘密鍵に設定するパスワードを入力してください");

            if(!pw){
                openNotify("処理をキャンセルしました");
                return;
            }

            const id = Array.from(crypto.getRandomValues(new Uint8Array(4))).map(n => n.toString(16)).join("");

            try{
                const {pub, sec} = await exportKey(pw);

                writeFile(pub, `key-${id}.pub`);
                writeFile(sec, `key-${id}.sec`);

                openNotify("処理が完了しました");
            }
            catch{
                openNotify("処理中にエラーが発生しました");
            }
        });
    </script>

    <style>
        ::-webkit-scrollbar{
            display: none !important;
        }
        body{
            user-select: none !important;
            margin: 0 !important;
            padding: 0 !important;
        }
        header{
            margin: 20px;
        }
        main{
            margin: 0 10px;
        }
        h1, h2, h3{
            margin: 0;
        }
        h3{
            margin-top: 16px;
        }
        section{
            margin-top: 20px;
        }
        p{
            margin: 10px;
        }
        details{
            margin: 10px;
        }
        summary{
            cursor: pointer;
            list-style-type: "\1F4D6";
        }
        input, button{
            cursor: pointer;
            box-sizing: border-box;
        }
        input{
            margin-top: 6px;
        }
        button{
            font-size: 14px;
            padding: 2px 8px;
        }
        ul, ol{
            margin: 0;
        }
        ul.input{
            list-style-type: "\1F4C2";
            margin: 10px 0 20px 30px;
            padding: 0;
        }
        ul.input > li{
            margin-bottom: 16px;
        }
        ul.input > li:last-of-type{
            margin-bottom: unset;
        }
    </style>
</html>