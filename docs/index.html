<!doctype html>
<html lang="ja">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, height=device-height, minimum-scale=1, maximum-scale=1, initial-scale=1, user-scalable=no">
        <meta name="referrer" content="no-referrer">

        <script>
            if(!window.SubtleCrypto || !window.HTMLDialogElement || !window.CompressionStream){
                alert("ご使用のウェブブラウザは非対応です。\nChromeまたはEdgeをお使いください。");
                stop();
            }
        </script>

        <title>公開鍵暗号化ツール</title>
    </head>

    <body>
        <header>
            <h1>公開鍵暗号化ツール</h1>
        </header>

        <main>
            <section>
                <h2>暗号化/復号</h2>

                <ul class="input">
                    <li>
                        <div>データ</div>
                        <input multiple type="file" id="data">
                    </li>

                    <li>
                        <div>公開鍵</div>
                        <input type="file" accept=".pub" id="public">
                    </li>

                    <li>
                        <div>秘密鍵</div>
                        <input type="file" accept=".sec" id="secret">
                    </li>
                </ul>

                <p>
                    <button type="button" id="encode">&#x1F512; 暗号化</button>
                    <button type="button" id="decode">&#x1F513; 復号</button>
                    <button type="button" id="generate">&#x1F511; 鍵生成</button>
                </p>
            </section>

            <section>
                <h2>ドキュメント</h2>

                <details>
                    <summary>使用方法</summary>

                    <h3>STEP1: 鍵を生成する (操作: 送信者/受信者)</h3>
                    <ol>
                        <li>送信者と受信者は、それぞれ <a href="#generate">鍵生成</a> ボタンを押し、処理を開始します。</li>
                        <li>秘密鍵を保護するためのパスワード設定を求められるので、推測されにくい値を入力します。</li>
                        <li>処理が完了すると、2個のファイルがダウンロードされます。(許可を要求された場合は許可します)</li>
                        <ul>
                            <li><code>key-{乱数}.pub</code> : 公開鍵(公開しても問題ない)</li>
                            <li><code>key-{乱数}.sec</code> : 秘密鍵(絶対に公開してはいけない)</li>
                        </ul>
                    </ol>

                    <h3>STEP2: 公開鍵を交換する (操作: 送信者/受信者)</h3>
                    <ol>
                        <li>送信者と受信者は、それぞれ生成した <code>key-{乱数}.pub</code> を、電子メールなどで相互に交換します。</li>
                    </ol>

                    <h3>STEP3: 暗号化を行う (操作: 送信者)</h3>
                    <ol>
                        <li>送信者は、ツールの各フォームへファイルを入力します。</li>
                        <ul>
                            <li><a href="#data">データ</a> フォーム : 暗号化したいファイル (複数指定可能)</li>
                            <li><a href="#public">公開鍵</a> フォーム : 受信者から受け取った <code>key-{乱数}.pub</code></li>
                            <li><a href="#secret">秘密鍵</a> フォーム : 自身で生成した <code>key-{乱数}.sec</code></li>
                        </ul>
                        <li><a href="#convert">暗号化/復号</a> ボタンを押し、処理を開始します。</li>
                        <li>秘密鍵のパスワードを求められるので、鍵生成のときに設定したパスワードを入力します。</li>
                        <li>処理が完了すると、1個のファイルがダウンロードされます。</li>
                        <ul>
                            <li><code>cipher.bin</code> : 暗号データ(公開しても問題ない)</li>
                        </ul>
                    </ol>

                    <h3>STEP4: 暗号データを送信する (操作: 送信者)</h3>
                    <ol>
                        <li>送信者は、暗号化された <code>cipher.bin</code> を、電子メールなどで受信者へ渡します。</li>
                    </ol>

                    <h3>STEP5: 暗号データを復号する (操作: 受信者)</h3>
                    <ol>
                        <li>受信者は、ツールの各フォームへファイルを入力します。</li>
                        <ul>
                            <li><a href="#data">データ</a> フォーム : 送信者から受け取った <code>cipher.bin</code></li>
                            <li><a href="#public">公開鍵</a> フォーム : 送信者から受け取った <code>key-{乱数}.pub</code></li>
                            <li><a href="#secret">秘密鍵</a> フォーム : 自身で生成した <code>key-{乱数}.sec</code></li>
                        </ul>
                        <li><a href="#convert">暗号化/復号</a> ボタンを押し、処理を開始します。</li>
                        <li>秘密鍵のパスワードを求められるので、鍵生成のときに設定したパスワードを入力します。</li>
                        <li>処理が完了すると、元のファイルがダウンロードされます。</li>
                    </ol>
                </details>

                <details>
                    <summary>技術仕様</summary>

                    <ul>
                        <li>実装: <a href="https://www.w3.org/TR/WebCryptoAPI" target="_blank" rel="noopener">Web Crypto API</a></li>
                        <li>鍵交換: <a href="https://ja.wikipedia.org/wiki/楕円曲線ディフィー・ヘルマン鍵共有" target="_blank" rel="noopener">ECDH</a></li>
                        <li>公開鍵: <a href="https://datatracker.ietf.org/doc/html/rfc4492" target="_blank" rel="noopener">NIST P-521</a> - 521bit Key</li>
                        <li>共通鍵: <a href="https://ja.wikipedia.org/wiki/Advanced_Encryption_Standard" target="_blank" rel="noopener">AES-GCM</a> - 256bit Key, 128bit Tag, 128bit IV (96bit Nonce + 32bit Counter)</li>
                    </ul>
                </details>

                <details>
                    <summary>安全性</summary>
                    <ul>
                        <li>暗号処理は全てローカルで完結するため、インターネット通信を伴う処理はありません。</li>
                        <li>サードパーティ製のライブラリは使用していません。</li>
                        <li>MITライセンス準拠のオープンソースソフトウェアとなります。</li>
                        <li>ハッシュ値: <a href="https://dojyorin.github.io/web-crypto/sha512.txt" target="_blank" rel="noopener">SHA512</a></li>
                        <li>リポジトリ: <a href="https://github.com/dojyorin/web-crypto" target="_blank" rel="noopener">GitHub</a></li>
                        <li>お問い合わせ: <a href="https://twitter.com/dojyorin" target="_blank" rel="noopener">Twitter</a></li>
                    </ul>
                </details>
            </section>
        </main>
    </body>

    <script async type="module">
        function $id(id){
            return document.getElementById(id);
        }

        function bufferJoin(...sources){
            const data = new Uint8Array(sources.reduce((a, {byteLength}) => a += byteLength, 0));

            let offset = 0;
            for(const source of sources){
                data.set(new Uint8Array(source?.buffer ?? source), offset);
                offset += source.byteLength;
            }

            return data.buffer;
        }

        function bufferEqual(source1, source2){
            const dv1 = new DataView(source1?.buffer ?? source1);
            const dv2 = new DataView(source2?.buffer ?? source2);

            return dv1.byteLength !== dv2.byteLength || new Array(dv1.byteLength).fill(null).every((_, i) => dv1.getUint8(i) === dv2.getUint8(i));
        }

        function dvSetQuad(n){
            const dv = new DataView(new ArrayBuffer(4));
            dv.setUint32(0, n);

            return dv.buffer;
        }

        function dvGetQuad(b){
            return new DataView(b).getUint32(0);
        }

        function toHex(data){
            return Array.from(new Uint8Array(data?.buffer ?? data)).map(n => n.toString(16).padStart(2, "0").toUpperCase()).join("");
        }

        function fsWrite(name, data){
            const anchor = document.createElement("a");
            anchor.download = name;
            anchor.href = URL.createObjectURL(new Blob([data]));

            anchor.click();

            URL.revokeObjectURL(anchor.href);
        }

        function dialogNotify(message){
            const dialog = document.createElement("dialog");
            dialog.style.position = "fixed";
            dialog.style.top = "10px";
            dialog.style.transition = "all 0.1s";
            dialog.style.border = "0";
            dialog.style.borderRadius = "8px";
            dialog.style.padding = "10px 15px";
            dialog.style.backgroundColor = "#CACACA";
            dialog.style.boxShadow = "2px 3px 4px 0 #0000004D";
            dialog.textContent = `\u{1F514} ${message}`;

            dialog.show();

            setTimeout(() => dialog.remove(), 5000);
            document.body.appendChild(dialog);
        }

        function packConfigHeader(){
            return {
                size: 4,
                hash: 64,
                name: 256
            };
        }

        function wcConfigPBKDF2(v){
            return {
                name: "PBKDF2",
                hash: "SHA-512",
                iterations: 0xFFFF,
                salt: v
            };
        }

        function wcConfigECC(){
            return {
                name: "ECDH",
                namedCurve: "P-521"
            };
        }

        function wcConfigECDH(v){
            return {
                name: "ECDH",
                public: v
            };
        }

        function wcConfigAES(){
            return {
                name: "AES-GCM",
                length: 256
            };
        }

        function wcConfigGCM(v){
            return {
                name: "AES-GCM",
                tagLength: 128,
                iv: v
            };
        }

        async function deflateEncode(data){
            return new Response(new Blob([data]).stream().pipeThrough(new CompressionStream("deflate"))).arrayBuffer();
        }

        async function deflateDecode(data){
            return new Response(new Blob([data]).stream().pipeThrough(new DecompressionStream("deflate"))).arrayBuffer();
        }

        async function packEncode(files){
            if(files.some(({size, name: {length}}) => size > ((0x100 ** packConfigHeader().size) - 1) || length > packConfigHeader().name)){
                throw "";
            }

            const archive = new Uint8Array(Object.values(packConfigHeader()).reduce((a, b) => a + b, 0) * files.length + files.reduce((a, {size}) => a + size, 0));

            let offset = 0;
            for(const file of files){
                const data = await file.arrayBuffer();

                archive.set(new Uint8Array(dvSetQuad(file.size)), offset);
                offset += packConfigHeader().size;
                archive.set(new Uint8Array(await wcHashDigest(data)), offset);
                offset += packConfigHeader().hash
                archive.set(new TextEncoder().encode(file.name), offset);
                offset += packConfigHeader().name
                archive.set(new Uint8Array(data), offset);
                offset += file.size;
            }

            return archive.buffer;
        }

        async function packDecode(archive){
            const files = [];

            let offset = 0;
            while(offset < archive.byteLength){
                const size = dvGetQuad(archive.slice(offset, offset += packConfigHeader().size));
                const hash = archive.slice(offset, offset += packConfigHeader().hash);
                const name = new TextDecoder().decode(archive.slice(offset, offset += packConfigHeader().name)).replace(/\0+$/, "");
                const data = archive.slice(offset, offset += size);

                if(!bufferEqual(hash, await wcHashDigest(data))){
                    throw "";
                }

                files.push(new File([data], name));
            }

            return files;
        }

        async function wcHashDigest(data){
            return crypto.subtle.digest("SHA-512", data);
        }

        async function wcDerivePassword(pw, salt){
            return crypto.subtle.deriveKey(wcConfigPBKDF2(salt), await crypto.subtle.importKey("raw", new TextEncoder().encode(pw), "PBKDF2", false, ["deriveKey"]), wcConfigAES(), false, ["wrapKey", "unwrapKey"]);
        }

        async function wcExportKey(pw){
            const iv = crypto.getRandomValues(new Uint8Array(12));
            const salt = crypto.getRandomValues(new Uint8Array(16));

            const {publicKey, privateKey} = await crypto.subtle.generateKey(wcConfigECC(), true, ["deriveKey"]);

            return {
                pub: await crypto.subtle.exportKey("spki", publicKey),
                sec: bufferJoin(iv, salt, await crypto.subtle.wrapKey("pkcs8", privateKey, await wcDerivePassword(pw, salt), wcConfigGCM(iv)))
            };
        }

        async function wcImportKey(pub, sec, pw){
            const vpub = new Uint8Array(pub?.buffer ?? pub);
            const vsec = new Uint8Array(sec?.buffer ?? sec);

            return {
                pub: await crypto.subtle.importKey("spki", vpub, wcConfigECC(), false, []),
                sec: await crypto.subtle.unwrapKey("pkcs8", vsec.subarray(28), await wcDerivePassword(pw, vsec.subarray(12, 28)), wcConfigGCM(vsec.subarray(0, 12)), wcConfigECC(), false, ["deriveKey"])
            };
        }

        async function wcDeriveKey(pub, sec){
            return crypto.subtle.deriveKey(wcConfigECDH(pub), sec, wcConfigAES(), false, ["encrypt", "decrypt"]);
        }

        async function wcEncryptData(com, data){
            const iv = crypto.getRandomValues(new Uint8Array(12));

            return bufferJoin(iv, await crypto.subtle.encrypt(wcConfigGCM(iv), com, data));
        }

        async function wcDecryptData(com, data){
            const vdata = new Uint8Array(data?.buffer ?? data);

            return crypto.subtle.decrypt(wcConfigGCM(vdata.subarray(0, 12)), com, vdata.subarray(12));
        }

        $id("encode").addEventListener("click", async()=>{
            if(!$id("data").files.length || $id("public").files.length !== 1 || $id("secret").files.length !== 1){
                dialogNotify("ファイルを選択してください");
                return;
            }

            const pw = prompt("秘密鍵に設定されているパスワード");

            if(!pw){
                dialogNotify("パスワードを入力してください");
                return;
            }

            dialogNotify("処理を開始しました");

            try{
                const {pub, sec} = await wcImportKey(await $id("public").files.item(0).arrayBuffer(), await $id("secret").files.item(0).arrayBuffer(), pw);

                fsWrite("cipher.bin", await wcEncryptData(await wcDeriveKey(pub, sec), await deflateEncode(await packEncode(Array.from($id("data").files)))));

                dialogNotify("処理が完了しました");
            }
            catch{
                dialogNotify("処理中にエラーが発生しました");
            }
        });

        $id("decode").addEventListener("click", async()=>{
            if($id("data").files.length !== 1 || $id("public").files.length !== 1 || $id("secret").files.length !== 1){
                dialogNotify("ファイルを選択してください");
                return;
            }

            const pw = prompt("秘密鍵に設定されているパスワード");

            if(!pw){
                dialogNotify("パスワードを入力してください");
                return;
            }

            dialogNotify("処理を開始しました");

            try{
                const {pub, sec} = await wcImportKey(await $id("public").files.item(0).arrayBuffer(), await $id("secret").files.item(0).arrayBuffer(), pw);

                for(const file of await packDecode(await deflateDecode(await wcDecryptData(await wcDeriveKey(pub, sec), await $id("data").files.item(0).arrayBuffer())))){
                    fsWrite(file.name, file);
                }

                dialogNotify("処理が完了しました");
            }
            catch{
                dialogNotify("処理中にエラーが発生しました");
            }
        });

        $id("generate").addEventListener("click", async()=>{
            const pw = prompt("秘密鍵に設定するパスワード");

            if(!pw){
                dialogNotify("パスワードを入力してください");
                return;
            }

            dialogNotify("処理を開始しました");

            try{
                const {pub, sec} = await wcExportKey(pw);
                const id = toHex(crypto.getRandomValues(new Uint8Array(4)));

                fsWrite(`key-${id}.pub`, pub);
                fsWrite(`key-${id}.sec`, sec);

                dialogNotify("処理が完了しました");
            }
            catch{
                dialogNotify("処理中にエラーが発生しました");
            }
        });
    </script>

    <style>
        ::-webkit-scrollbar{
            display: none !important;
        }
        body{
            user-select: none !important;
            margin: 0 !important;
            padding: 0 !important;
        }
        header{
            margin: 20px;
        }
        main{
            margin: 0 10px;
        }
        h1, h2, h3{
            margin: 0;
        }
        h3{
            margin-top: 16px;
        }
        section{
            margin-top: 20px;
        }
        p{
            margin: 10px;
        }
        details{
            margin: 10px;
        }
        summary{
            cursor: pointer;
            list-style-type: "\1F4D6";
        }
        input, button{
            cursor: pointer;
            box-sizing: border-box;
        }
        input{
            margin-top: 6px;
        }
        button{
            font-size: 14px;
            padding: 2px 8px;
        }
        ul, ol{
            margin: 0;
        }
        ul.input{
            list-style-type: "\1F4C2";
            margin: 10px 0 20px 30px;
            padding: 0;
        }
        ul.input > li{
            margin-bottom: 16px;
        }
        ul.input > li:last-of-type{
            margin-bottom: unset;
        }
    </style>
</html>